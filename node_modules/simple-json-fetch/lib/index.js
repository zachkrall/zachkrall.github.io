"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function (url, data) {
  return fetch(url, data).then(function (res) {

    // get response fields has a raw object
    var response = {};
    // using spread or Object.keys do not return computed properties
    // hasOwnProperty doesn't help
    // so good old `for in` that checks simple types
    for (var key in res) {
      if (typeof res[key] !== "function") {
        response[key] = res[key];
      }
    }

    // for both http ok/not ok, we try to parse as JSON
    // or reject if json parsing failed

    // http OK
    if (res.status >= 200 && res.status < 300) {
      return new Promise(function (resolve, reject) {
        return res.json().then(function (json) {
          return resolve(_extends({}, response, { json: json }));
        }, function (error) {
          return reject(_extends({}, response, { error: error }));
        });
      });
    }

    // http not ok
    return new Promise(function (resolve, reject) {
      return res.json().then(function (json) {
        return reject(_extends({}, response, { json: json }));
      }, function (error) {
        return reject(_extends({}, response, { error: error }));
      });
    });
  });
};