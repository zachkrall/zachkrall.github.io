"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

exports.getId = getId;
exports.formatDate = formatDate;
exports.getFieldValue = getFieldValue;
exports.injectData = injectData;
exports.parsePath = parsePath;

exports.default = function () {
  return {
    name: "@phenomic/plugin-collector-files",
    collect: function collect(db, name, json) {
      name = normalizeWindowsPath(name);
      var id = getId(name, json);

      var _parsePath = parsePath(name),
          filename = _parsePath.filename,
          allPaths = _parsePath.allPaths;

      var adjustedJSON = injectData(filename, json);
      debug("collecting " + filename, adjustedJSON);
      // full resource, not sorted
      db.put(null, id, adjustedJSON);
      return _promise2.default.all(allPaths.map(function (pathName) {
        var relativeKey = id.replace(pathName + sep, "");
        var sortedKey = relativeKey;
        debug("collecting " + relativeKey + " for path '" + pathName + "'");
        return _promise2.default.all([db.put([pathName], relativeKey, adjustedJSON), db.put([pathName, "default"], sortedKey)].concat((0, _toConsumableArray3.default)((0, _keys2.default)(json.data).map(function (type) {
          return getFieldValue(json, type).map(function (value) {
            return _promise2.default.all([db.update([pathName, type, value], sortedKey),
            // db.update([type], value),
            db.update([type, "default"], value), db.update([type, "path", pathName], value)]);
          });
        }))));
      }));
    }
  };
};

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require("debug")("phenomic:plugin:collector-files");

var sep = "/";
function normalizeWindowsPath(value) {
  return value.replace(/(\/|\\)+/g, sep);
}

function getId(name, json) {
  if (json.data.path) {
    debug("id for '" + name + "' is '" + json.data.path + "' (from json)");
    return json.data.path;
  }
  // normalize windows path
  name = normalizeWindowsPath(name);
  // remove (index).md,json etc, for id
  var id = name
  // remove extension for prettier keys
  .replace(/.(md|json)$/, "")
  // remove index too
  .replace(/\/index$/, "");
  debug("id for '" + name + "' is '" + id + "' (automatically computed)");
  return id;
}

function formatDate(dateString) {
  var date = new Date(dateString).toISOString();
  return date.substring(0, date.indexOf("T"));
}

function isLiteral(value) {
  var type = typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value);
  return type === "string" || type === "number" || type === "boolean";
}

function isArrayOfLiterals(array) {
  return Array.isArray(array) && array.every(isLiteral);
}

function getFieldValue(json, id) {
  if (isArrayOfLiterals(json.data[id])) {
    return json.data[id];
  }
  if (isLiteral(json.data[id])) {
    return [json.data[id]];
  }
  return [];
}

var dateLength = "YYYY-MM-DD".length;
function injectData(name, json) {
  var injectedData = {
    filename: name
  };
  try {
    injectedData.date = formatDate(name.slice(0, dateLength));
  } catch (e) {
    // assuming date is not valid
  }
  return {
    data: (0, _extends3.default)({}, injectedData, json.data),
    partial: (0, _extends3.default)({}, injectedData, json.partial)
  };
}

function parsePath(name) {
  var pathSegments = name.split(sep);
  var allPaths = pathSegments.reduce(function (acc, v) {
    acc.push(acc.length > 0 ? acc[acc.length - 1] + sep + v : v);
    return acc;
  }, []);
  var filename = pathSegments[pathSegments.length - 1];
  return { filename: filename, allPaths: allPaths };
}