"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require("babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _query = require("@phenomic/api-client/lib/query");

var _query2 = _interopRequireDefault(_query);

var _api = require("../api");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require("debug")("phenomic:core:prerender:resolve");

var defaultQueryKey = "default";
var mainKey = "id";

var arrayUnique = function arrayUnique(array) {
  return [].concat((0, _toConsumableArray3.default)(new _set2.default(array)));
};

var flatten = function flatten(array) {
  var flattenedArray = [];
  array.forEach(function (item) {
    Array.isArray(item) ? flattenedArray.push.apply(flattenedArray, (0, _toConsumableArray3.default)(flatten(item))) : flattenedArray.push(item);
  });

  return flattenedArray;
};

var getRouteQueries = function getRouteQueries(route) {
  if (
  // reference is incorrect? (eg: import { Thing } instead of import Thing)
  !route.component ||
  // no export?
  (0, _keys2.default)(route.component).length === 0 && route.component.constructor === Object) {
    throw new Error("Route with path '" + route.path + "' have no component (or an undefined value).\n" + "Check the component reference and its origin. Are the import/export correct?");
  }
  var initialRouteParams = route.params || {};
  if (!route.component.getQueries) {
    debug(route.path, "have no queries");
    return {};
  }
  return route.component.getQueries({
    params: initialRouteParams
  });
};

var getMainQuery = function getMainQuery(route) {
  var routeQueries = getRouteQueries(route);
  var keys = (0, _keys2.default)(routeQueries);
  var firstKey = keys[0];
  var firstKeyAsInt = parseInt(keys[0], 10);
  // parseInt("12.") == "12"
  if (
  // $FlowFixMe it's on purpose
  firstKeyAsInt == firstKey && String(firstKeyAsInt).length == firstKey.length) {
    console.warn("The main path used for " + route.path + " is " + firstKey);
  }
  return { key: firstKey, item: routeQueries[firstKey] };
};

var resolveURLsForDynamicParams = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(phenomicFetch, route) {
    var mainQuery, unlimitedQueryConfig, queries, key, queryParams, queryResult, path, list, urlsData, finalUrlsData, reAfter;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // deprecate notice
            // @todo remove for stable v1
            if (route.paginated) {
              console.log("'paginated' parameter is deprecated. Pagination is now infered from the presence of :after param in the route.");
            }
            if (route.collection) {
              console.error(
              // $FlowFixMe removed from interface but it's for deprecation that we use it
              route.path + " have an attached parameter 'collection=" + route.collection + "'.\n This parameter is now useless and can be safely removed");
            }

            mainQuery = getMainQuery(route);

            if (mainQuery.item) {
              _context.next = 6;
              break;
            }

            debug("no valid path detected for", route.path);
            return _context.abrupt("return", route);

          case 6:
            unlimitedQueryConfig = { path: mainQuery.item.path };

            debug("route", route.path);

            // If the path doesn't contain any kind of parameter, no need to
            // iterate over the path

            if (!(!route.path.includes("*") && !route.path.includes(":"))) {
              _context.next = 11;
              break;
            }

            debug("not a dynamic route");
            return _context.abrupt("return", route);

          case 11:
            debug("fetching path '" + (mainQuery.key ? mainQuery.key : (0, _keys2.default)(unlimitedQueryConfig).join(",")) + "' for route '" + route.path + "'");
            // @todo memoize for perfs and avoid uncessary call
            queries = getRouteQueries(route);

            debug(route.path, queries);
            key = queries[mainQuery.key] && queries[mainQuery.key].by || mainKey;

            if (key === defaultQueryKey) {
              key = mainKey;
            }
            queryParams = (0, _query2.default)(unlimitedQueryConfig);
            _context.next = 19;
            return phenomicFetch(queryParams);

          case 19:
            queryResult = _context.sent;

            debug(route.path, "path fetched. " + queryResult.list.length + " items (id: " + key + ")");
            path = route.path || "*";
            list = queryResult.list.reduce(function (acc, item) {
              if (!item[key]) {
                return acc;
              }
              if (Array.isArray(item[key])) {
                acc = acc.concat(item[key]);
              } else {
                acc.push(item[key]);
              }
              return acc;
            }, []);

            debug(path, "list (unique)", arrayUnique(list));
            urlsData = arrayUnique(list).reduce(function (acc, value) {
              var resolvedPath = path.replace(":" + key, value);
              var params = (0, _defineProperty3.default)({}, key, value);

              // try *
              if (key === mainKey && resolvedPath === path) {
                resolvedPath = resolvedPath.replace("*", value);
                // react-router splat is considered as the id
                params = { splat: value };
              }

              debug("half resolved path", resolvedPath, params);

              if (path !== resolvedPath) {
                acc.push((0, _extends3.default)({}, route, {
                  path: resolvedPath,
                  params: params
                }));
              }

              return acc;
            }, []);


            debug(path, "urls data", urlsData);

            // if no data found, we still try to render something
            finalUrlsData = urlsData.length ? urlsData : [{ path: path }];
            // try :after with key

            reAfter = /:after\b/;
            return _context.abrupt("return", finalUrlsData.reduce(function (acc, routeData) {
              if (!routeData.path.match(reAfter)) {
                acc.push(routeData);
              } else {
                queryResult.list.map(function (item) {
                  // $FlowFixMe params[key] act as a truthy value
                  if (routeData.params && routeData.params[key]) {
                    if (Array.isArray(item[key]) && item[key].includes(routeData.params[key]) || item[key] === routeData.params[key]) {
                      acc.push((0, _extends3.default)({}, routeData, {
                        path: routeData.path.replace(reAfter, (0, _api.encode)(item.id))
                      }));
                    }
                  } else {
                    acc.push((0, _extends3.default)({}, routeData, {
                      path: routeData.path.replace(reAfter, (0, _api.encode)(item.id))
                    }));
                  }
                });
              }

              return acc;
            }, []));

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function resolveURLsForDynamicParams(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var normalizePath = function normalizePath(path) {
  return path.replace(/^\//, "");
};

var resolveURLsToPrerender = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(routes, fetch) {
    var dynamicRoutes, flattenedDynamicRoutes, filtredDynamicRoutes, normalizedURLs, uniqsNormalizedPath;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return _promise2.default.all(routes.map(function (route) {
              return resolveURLsForDynamicParams(fetch, route);
            }));

          case 2:
            dynamicRoutes = _context2.sent;
            flattenedDynamicRoutes = flatten(dynamicRoutes);
            filtredDynamicRoutes = flattenedDynamicRoutes.filter(function (url) {
              if (url.path && url.path.includes("*")) {
                debug(url.path + " is including a '*' but it has not been resolved: url is skipped");
                return false;
              }
              return true;
            });
            // debug("filtred dynamic routes", filtredDynamicRoutes)

            normalizedURLs = filtredDynamicRoutes.map(function (routeData) {
              return normalizePath(routeData.path);
            });

            debug("normalize urls", normalizedURLs);
            uniqsNormalizedPath = [].concat((0, _toConsumableArray3.default)(new _set2.default(normalizedURLs)));
            return _context2.abrupt("return", uniqsNormalizedPath);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function resolveURLsToPrerender(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

exports.default = resolveURLsToPrerender;